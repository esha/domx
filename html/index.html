<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>DOMx - Time to Extend the DOM!</title>
  <meta name="description" content="An intuitive, extensible JavaScript library to work directly with the DOM.">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->

  <link rel="stylesheet" type="text/css" href="style/domx-docs.css"/>
  <link href="favicon.ico" rel="shortcut icon" type="image/x-icon"/>
</head>
<body>
<!--[if lt IE 10]>
  <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
<![endif]-->
    <header>
    <div class="wrapper">
      <h5><a href="https://twitter.com/share" class="twitter-share-button" data-via="nadabu">Tweet</a>
      <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
      <a id="github-ribbon" target="_blank" href="https://github.com/esha/domx"><img alt="View me on GitHub" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>
      <h1 class="logo">
        <span id="DOMx">DOMx</span>
      </h1>
      <h3 class="motto">Befriend the DOM!</h3>

    </div>
  </header>
  <div class="content">
    <div class="wrapper">
      <div class="info">
        <p>DOMx is all about powerful, lightweight, native DOM interaction. Try it: &nbsp; <a class="download" href="domx.min.js.gz">domx.min.js (~5kb, gzip)</a></p>

      </div>
      <demo-x class="block-group">
        <div class="half block">
          <h3>
            Code &nbsp;
            <a name="Demo" class="controls">
              <span title="Pause" stop>&#9612;&#9612;</span>
              <span title="Play" start>&#9654;</span>
            </a>
          </h3>
          <demo-in wrap="off" contenteditable="true">
            <pre>document.body.div</pre>
            <pre>document.body.div.section</pre>
            <pre>document.body.div.section.only(0)</pre>
            <pre>document.body.div.section.only('#full')</pre>
            <pre>document.body.div.section.ul.li.each('id', 'item${i}')</pre>
            <pre>document.query('#empty')</pre>
            <pre>document.query('#empty').append('h1')</pre>
            <pre>document.query('#empty').append('ul>li{item}*5')</pre>
            <pre>document.queryAll('#empty li').each(function(el, i, all) {
  el.textContent += ' '+(i+1)+' of '+all.length;
})</pre>
            <pre>document.queryAll('#empty li').only(function(el, i) {
  return i % 3;
}).each('className','special')</pre>
            <pre>document.queryAll('#empty li').not('.special').each('textContent')</pre>
            <pre>document.queryAll('#empty *').remove()</pre>
            <pre>//Now you try it out for yourself! Edit me.</pre>
          </demo-in>
          <h3>Returns</h3>
          <demo-out></demo-out>
        </div>
        <div class="half block">
          <h3>DOM</h3>
          <demo-dom x-dot>
            <div>
              <h1>Hello world!</h1>
              <section id="empty"></section>
              <section id="full">
                <ul>
                  <li>foo</li>
                  <li>bar</li>
                  <li>baz</li>
                </ul>
              </section>
            </div>
          </demo-dom>
        </div>
      </demo-x>
      <div class="features block-group">
        <div class="third block">
          <h3>Native</h3>
          <p>DOMx supports native DOM interfaces and features, rather than obscuring them behind wrapper objects with new APIs.</p>
        </div><div class="third block">
          <h3>Capable</h3>
          <p>DOMx provides powerful utility functions for using the native DOM, providing full and flexible DOM library features with minimal overhead.</p>
        </div><div class="third block">
          <h3>Friendly</h3>
          <p>DOMx makes the verbose and unwieldy DOM API intuitive and easy to use, extend, and even abbreviate if need be.</p>
        </div>
      </div>
      <div class="info">
        <p>See our <a href="#FAQ">F.A.Q.</a>!</p>
      </div>
      <hr>
      <a name="API"><h2>API</h2></a>
      <div class="api">
        <article>
          <h4><a name="document">document</a> <span class="returns">document</span></h4>
          <p>No need for a new global variable. We're <em>extending</em> the DOM, not replacing it. If you want a shorter global variable, do this:</p>
          <pre class="example">
window.$ = document.queryAll.bind(document);
</pre>
          <p>or, you can do what i do and alias <code>document</code> to <code>D</code> in the <a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression">IIFE</a> that should be wrapping your code anyway:</p>
          <pre class="example">
(function(D) {
  D.body.classList.append('hooray');
  ...
}(document));
</pre>
        </article>
        <article>
          <h4><a name="queryAll()">queryAll</a>(<span class="variable string">selector</span>) <span class="since">0.7.0</span></h4>
          <p>
            <code>document.queryAll</code> polyfills the upcoming <a href="http://dom.spec.whatwg.org/#dom-parentnode-queryall"><code>queryAll</code></a> and returns a list of the selected element(s). DOMx enables it not merely for <a href="http://dom.spec.whatwg.org/#parentnode">elements</a> but for lists of elements.
          </p>
          <pre class="example">
document.queryAll(".example"); // list of nodes returned

var parents = document.queryAll(".parents");
...
var allkids = parents.queryAll(".children");
</pre>
        </article>
        <article>
          <h4><a name="query()">query</a>(<span class="variable string">selector</span>) <span class="since">0.7.0</span></h4>
          <p>
            <code>document.query</code> acts like <code>querySelector</code> and returns only the first selected element.
            It is exists not merely because it is shorter, but because it is <a href="http://dom.spec.whatwg.org/#dom-parentnode-query">the future</a> and
            DOMx enables it not merely for <a href="http://dom.spec.whatwg.org/#parentnode">elements</a> but for lists of elements.
          </p>
          <pre class="example">
var parent = document.query(".parent"); // single matching element returned

var allkids = parent.queryAll(".kid"); // queryAll returns list
...
var firstGrandkid = kids.query(".grandkid"); // query works across list, returns single element
</pre>
        </article>
        <article>
          <h4><a name="each()">each</a>(<span class="variable">callback(<em>element</em>,<em>index</em>,<em>array</em>)</span>) <span class="since">0.7.0</span></h4>
          <p>Use a the selected element(s) within a closure. Returns the element(s) it was called on.</p>
          <pre class="example">
document.queryAll('li').each(function(el, i, all) {
  el.textContent = "Item " + (i+1) + " of " + all.length;
}); // returns li elements
</pre>
        </article>
        <article>
          <h4><a name="each(property)">each</a>(<span class="variable string">property</span> <span class="variable optional">, arguments...</span>) <span class="since">0.7.0</span></h4>
          <p>Get, set, or invoke the specified property of the selected element(s). Returns either an array of retrieved/returned values or the element(s) it was called on.</p>
          <pre class="example">
var items = document.queryAll('.item');
var texts = items.each('textContent'); // returns array of strings

items.each('id', 'item${i}');// sets the id of each element (replaces ${i} with index)

items.each('click');// calls 'click()' on each element, returns original items

items.each('classList.add', 'foo');// adds 'foo' class to each item's classList, returns original items

document.body.each('classList.toggle', 'ready');// each works on both single elements and lists
</pre>
        </article>
        <article>
          <h4><a name="only()">only</a>(<span class="variable">selector|index|filter|slice|property</span> <span class="variable optional">, endSlice|value</span>) <span class="since">0.7.0</span></h4>
          <p>When you want to narrow down a selection, <code>only</code> allows you to easily filter
          that list by selector, index, slice, or filtering function.</p>
          <pre class="example">
var items = document.queryAll('.item'); // all items

items.only(':nth-child(even)'); // subset that matches selector

items.only(3).textContent = "Fourth item!"; // index (special case, returns single element)

items.only(-1).id = 'last'; // negative index works too

items.only(function(el,i){ return el.id.indexOf(i) > 0; }); // arbitrary filter function

items.only(3, 9);// specific slice of elements

items.only('textContent', 'example');// only items with 'example' as the content
</pre>
        </article>
        <article>
          <h4><a name="not()">not</a>(<span class="variable">selector|index|filter|slice|property</span> <span class="variable optional">, endSlice|value</span>) <span class="since">0.9.0</span></h4>
          <p>This exactly reverses the behavior of <a href="#only()">only()</a>.</p>
          <pre class="example">
var items = document.queryAll('.item'); // all items

items.not(':nth-child(even)'); // subset that does not match the selector

items.not(3).each('textContent', "Not the fourth!"); // returns all items except the fourth one

items.not(-1).each('setAttribute', 'not-last', 'true'); // negative index works too

items.not(function(el, i){ return el.id.indexOf(i) > 0; }); // all items whose ids do not contain their index

items.not(3, 9);// all items outside the specified slice

items.not('tagName', 'DIV');// all items that are not &lt;div&gt; elements
</pre>
        </article>
        <article>
          <h4><a name="all()">all</a>(<span class="variable string">property</span> <span class="variable optional">, function</span> <span class="variable optional">, includeSelf</span>) <span class="since">0.9.0</span></h4>
          <p>This function accumulates (and optionally acts upon) nodes recursively via the specified property. Beginning with the node(s) this is called upon, <code>all()</code> resolves the property then calls itself upon the result, gather each node or nodes found along the way. You may optionally provide a function to act on the nodes as <code>all()</code> travels the DOM tree. This function could also affect what nodes are gathered by what it returns. Also, you may optionally include the current node(s) as the first, rather than beginning with the resolved property.</p>
          <p>When using a function:
           <ul>
             <li>The context of the function will be the node currently having the property resolved against it.</li>
             <li>The function will receive as arguments, the resolved value for the current node and the list of accumulated nodes/values.</li>
             <li>Returning <code>undefined</code> will not affect the accumulated list of nodes</li>
             <li>Returning <code>null</code> will cause the "next" value (i.e. the current first arg) to be left out of the list</li>
             <li>Returning anything else will cause the returned value to be put in the list instead of the "next" value</li>
          </ul></p>
          <p>This is a very powerful utility for selecting and/or acting upon well-defined, but often unwieldy properties of the DOM tree.</p>
          <pre class="example">
var focused = focusEvent.target.all('parentElement', true); // gets list of all elements containing the focus

var active = document.query('td.active');
active.all('nextElementSibling').each('classList.add', 'next');// mark all subsequent cells in the row
active.all('previousElementSibling', function(previousElementSibling, all) {
  this.classList.remove('next');
}, true);// uses a function instead of each, and includes self
</pre>
        </article>
        <article>
          <h4><a name="closest()">closest</a>(<span class="variable optional">property</span> <span class="variable optional">, selector|function</span> <span class="variable optional">, includeSelf</span>) <span class="since">0.11.0</span></h4>
          <p>In the absence of arguments, this returns the parent element (or self, if none). If given only a selector (or custom test function), it will follow the <code>parentElement</code> chain until it finds one that matches the selector, returning <code>null</code> if none match. So long as no <span class="variable">property</span> is specified, <span class="variable">includeSelf</span> will default to <code>true</code>. If a property is specified, it will
          default to <code>false</code>.</p>
          <pre class="example">
var container = event.target.closest('.container'); // gets the closest element with 'container' class

var active = document.query('.active');
active.closest('nextElementSibling', '.action');// retrieves the closest, subsequent sibling with 'action' class
active.closest('parentNode', function(node) {
  return node.value && node.value.indexOf('example') >=0;
}, true);// returns the closest node (self-included) with a value that includes the string 'example'
</pre>
        </article>
        <article>
          <h4><a name="farthest()">farthest</a>(<span class="variable optional">property</span> <span class="variable optional">, selector|function</span> <span class="variable optional">, includeSelf</span>) <span class="since">0.11.0</span></h4>
          <p>In the absence of arguments, this returns the farthest parent element (or self, if none). If given only a selector (or custom test function), it will follow the <code>parentElement</code> chain until it finds one that matches the selector, returning <code>null</code> if none match. So long as no <span class="variable">property</span> is specified, <span class="variable">includeSelf</span> will default to <code>true</code>. If a property is specified, it will
          default to <code>false</code>.</p>
          <pre class="example">
var container = event.target.farthest('.container'); // gets the farthest element with 'container' class

var active = document.query('.active');
active.farthest('nextElementSibling', '.action');// retrieves the farthest, subsequent sibling with 'action' class
active.farthest('parentNode', function(node) {
  return node.value && node.value.indexOf('example') >=0;
}, true);// returns the farthest node (self-included) with a value that includes the string 'example'
</pre>
        </article>
        <article>
          <h4><a name="toArray()">toArray</a>(<span class="variable optional">array</span>) <span class="since">0.7.0</span></h4>
          <p>Returns an actual <code>Array</code> of elements instead of a list object (e.g. <code>NodeList</code>).
          Optionally, you can provide an array into which the elements should be pushed.</p>
          <pre class="example">
var items = document.queryAll('.items');
fnThatTakesItemsAsArgs.apply(this, items.toArray());

var output = items.toArray().map(fnThatConvertsElements);

var elArr = [document.body, document.head];
items.toArray(elArr);// will append all .item elements to the existing array
</pre>
        </article>
        <article>
          <h4><a name="dot()">dot()</a> and <a name="x-dot">[x-dot]</a> <span class="since">0.9.0</span></h4>
          <p>Turns on <a href="#dot-traversal">dot traversal</a> properties for the target element (or list) and all descendant elements.</p>
          <pre class="example">
document.dot(); // activates dot-traversal for all elements in the document
document.query('div').dot();// enables dot-traversal for the first div and its descendants
</pre>
          <div class="example">&lt;body x-dot&gt;&lt;!-- enable dot-traversal --&gt;
  &lt;header&gt;
    &lt;h1&gt;Title&lt;/h1&gt;
    This is the rest of the header.
  &lt;/header&gt;
  ...
&lt;/body&gt;
</div>
        </article>
        <article>
          <h4><a name="dot-traversal">element.<span class="variable tag">tagName...</span></a> <span class="since">0.9.0</span></h4>
          <p>DOMx allows you <a href="#dot()">to turn on</a> access to child elements via their tag name as a property. It acts a bit like <code>getElementsByTagName</code> except that it searches only immediate children and not all descendant elements. The dot-traversal properties <em>always</em> return a list of matching elements.</p>
          <p>This should <em>NOT</em> be used for long chains, as that would be fragile design. This is designed to be a powerful convenience feature for
          stable DOM structures (think <code>ul.li</code>, <code>table.tbody.tr</code>, and such) when dot-traversal is enabled on them either declaratively or programmatically.</p>
          <pre class="example">
document.body.header; // returns a list containing only header element that are children of document.body
document.body.header.h1; // returns a list of h1 elements that are children of header elements that are children of document.body
document.body.header.h1[0].textContent = "A Better Title!";
document.body.$text; // returns list of all text nodes that are children of the body
document.body.$comment; // returns list of all comment nodes that are children of the body
</pre>
        </article>
        <article>
          <h4><a name="append()">append</a>(<span class="variable">name|Node|list</span>) <span class="since">0.7.0</span></h4>
          <p>This automatically appends the specified tag or node (or list thereof) to the element(s) on which it was called.</p>
          <pre class="example">
document.body.append('div'); // returns a newly added div element

document.body.append('div').append('h1'); // returns the new h1 element (with div parent)

var script = document.createElement('script');
script.src = '/mylib.js';
document.head.append(script);

document.body.append([node1, node2, [ul1, ul2]]); // yummy recursive append
</pre>
        </article>
        <article>
          <h4><a name="append(emmet)">append</a>(<span class="variable string">emmet-abbr</span>) <span class="since">0.7.0</span></h4>
          <p>The standard document.js artifact comes with the "emmet" extension, which lets you use
          <a href="http://docs.emmet.io/abbreviations/syntax/">emmet abbreviations</a> to append elements to the DOM.
          This extension supports most emmet features, except grouping and numbering. Those may be added later.</p>
          <pre class="example">
document.body.append('ul>li{list item text}*10');

//Use in conjuction with only
document.body.append('ul>li{item}*10')
  .only(':nth-child(odd)')
  .each('classList.add','odd');
</pre>
        </article>
        <article>
          <h4><a name="remove()">remove</a>()</h4>
          <p>Removes the specified node (or list thereof). Some browsers provide this natively for elements, for the few who don't this polyfills the gap and enables use of it on arrays of elements. When called on a list, it returns the list of deleted items.</p>
          <pre class="example">
document.queryAll('.foo').remove();
</pre>
        </article>
        <article>
          <h4><a name="xValue">xValue</a> <span class="since">0.13.0</span></h4>
          <p>Property with dynamic get/set functions that pull/push rich values from/to
          the DOM structure of the contextual node. This will automatically parse/stringify JSON values, handles nested structures, and supports ${name} syntax for text nodes. Please note that this does not establish any binding between
          the nodes and values or objects returned. It is a straightforward read/write.</p>
          <div class="example">&lt;div name="person"&gt;
  &lt;pre name="address"&gt;${street},
${city}, ${state} ${zip}&lt;/pre&gt;
&lt;/div&gt;
</div>
          <pre class="example">
var person = document.queryName('person');// returns div[name=person]
person.xValue = {
  address: {
    street: '1600 Pennsylvania Ave NW',
    city: 'Washington',
    state: 'DC',
    zip: 20400
  }
};
var zip = person.xValue.address.zip;// returns 20400
document.queryName('person.address.zip').xValue = 20500;// correct just the zip
zip = person.xValue.address.zip;// returns 20500
</pre>
        </article>
        <article>
          <h4><a name="queryName">queryName</a>(<span class="variable string">name</span>) <span class="since">0.10.0</span></h4>
          <p>Finds the first descendent node with the specified name (attribute or property). This respects both nested element names and ${name} syntax in text content, though it will ignore the name of the node(s) this is called upon.</p>
          <div class="example">&lt;div name="person"&gt;
  &lt;pre name="address"&gt;${street}
${city}, ${state} ${zip}
  &lt;/pre&gt;
&lt;/div&gt;
</div>
          <pre class="example">
var address = document.queryName('person.addres');// returns pre[name=address]
address.xValue = { zip: 97216 };// sets the zip field
address.queryName('zip').textContent;// returns the text '97216'
</pre>
        </article>
        <article>
          <h4><a name="queryNameAll">queryNameAll</a>(<span class="variable string">name</span>) <span class="since">0.13.0</span></h4>
          <p>Finds all descendent nodes with the specified name (attribute or property). This respects nested element names and ${name} syntax in text content, though it will ignore the name of the node(s) this is called upon.</p>
          <div class="example">&lt;form name="person"&gt;
  &lt;input name="character" type="checkbox" value="P"&gt;Pirate
  &lt;input name="character" type="checkbox" value="N"&gt;Ninja
  &lt;input name="character" type="checkbox" value="Z"&gt;Zombie
&lt;/form&gt;
</div>
          <pre class="example">
var opts = document.queryNameAll('person.character');// list w/3 checkboxes
</pre>
        </article>
        <article>
          <h4>document.<a name="extend">x.add</a>(<span class="variable string">name</span>, <span class="variable">function|propertyDefinition</span>); <span class="since">0.14.0</span></h4>
          <p>Use this to extend the DOM. It automatically, correctly applies your function or getter/setters to both single elements and lists. Just don't get crazy with the cute shortcut methods. The DOM already has a lot of native capabilities, and DOMx is about exposing, learning, and using those, not obscuring the DOM beneath non-native interfaces.</p>
          <pre class="example">
document.x.add('hide', function() {
  this.style.display = 'none';  
});
document.queryAll('.foo').hide();

document.x.add('words', {
  get: function() {
    return this.textContent
      .trim()
      .match(/\b[^\s]*\b/g)
      .filter(function(v,i,a) {
        return a.indexOf(v) === i;
      });
  }
});
var wordCount = document.query('#essay').words.length;
</pre>
        </article>
        <article>
          <h4>document.<a name="x.alias">x.alias</a>(<span class="variable string">alias</span>, <span class="variable string">property</span>)<span class="since">0.14.0</span></h4>
          <p>Nonetheless, the verbosity of the DOM can, like any friend, become tiresome. You may create property aliases for <code>each</code>.</p>
          <pre class="example">
document.x.alias('-class', 'classList.remove');
document.x.alias('+class', 'classList.add');
document.queryAll('.foo').each('-class', 'foo').each('+class', 'bar');

document.x.alias('insert', 'insertAdjacentHTML');
document.queryAll('.neighbor').each('insert', 'afterend', '&amp;lt;span&amp;gt;Hello.&amp;lt;/span&amp;gt;');

// get crazy...
var abbrs = {
    '>': 'nextElementSibling',
    '&lt;': 'previousElementSibling',
    '^': 'parentElement',
    ...
}
for (var abbr in abbrs) {
    document.x.alias(abbr, abbrs[abbr]);
}
var parents = el.all('^'),
    nextActiveSib = el.closest('>', '.active'),
    firstSib = el.furthest('&lt;');
</pre>
        </article>
      </div>
      <hr>
      <h2><a name="FAQ">FAQ</a></h2>
      <div class="faq">
        <p class="question">Another jQuery clone, eh?</p>
        <p>Definitely not. jQuery and <a href="zeptojs.com">friends</a> always hide the DOM and its functions behind a different API. They did so to protect users from the inconsistencies, verbosity, and paucity of features that plagued the DOM of old. But the DOM of the present is not the mess it was even a few short years ago; protection from it is more pointless with every passing month. In fact, more than being unnecessary, that "protection" is often stunting your education. DOMx's intent is to support the native DOM, enhancing it and reducing verbosity without obscuring it in the process.</p>
        <p class="question">Why not just use jQuery?</p>
        <p>Why use jQuery? The <a href="https://developer.mozilla.org/en-US/docs/Web/API">riches of</a> <a href="http://docs.webplatform.org/wiki/dom#Index_of_all_DOM_topics">the modern DOM</a> make it <a href="http://youmightnotneedjquery.com">largely superfluous</a>. jQuery's size will also make it burdensome and divisive to the coming web component ecosystem, where <a href="http://tjvantoll.com/2014/08/12/the-problem-with-using-html-imports-for-dependency-management/">third party dependencies are likely to be a problem</a>, especially large ones. There is ample room for smaller DOM libraries that solve new problems.</p>
        <p class="question">I thought we were supposed to extend the DOM with <a href="http://webcomponents.org/">web components</a>!</p>
        <p>You are! But let's not pretend that web components will ever mean you don't need to manipulate and traverse the DOM directly. And when you want to do that within some fancy-pants web component, you might find yourself wanting a bit more power than the vanilla DOM gives. Then, instead of importing a big library like jQuery, you'll be glad to have the power of DOMx in just a few kilobytes. And even when web components reign supreme, there will always be a place for page-wide work to be done.
        </p>
        <p class="question">Which browsers does DOMx support?</p>
        <p>Modern ones: Firefox, Chrome, Safari, Opera, IE10+ and the like.</p>
        <p class="question">Isn't extending the DOM <a href="http://perfectionkills.com/whats-wrong-with-extending-the-dom/">a bad idea</a>?</p>
        <p>The modern DOM is no china shop, but if you blunder about like a bull, you <i>might</i> manage to get in trouble. In general, unless you care to prop up the diminishing market share of IE6/7/8, <a href="https://github.com/nbubna/mind-hacking/blob/gh-pages/extending-the-dom.md">DOM extension</a> is no longer to be feared, just employed with consideration for possible API conflicts.</p>
        <p class="question">How does the dot-traversal work?</p>
        <p>By dynamically defining getter functions for the elements you use in the page.</p>
        <p class="question">Aren't those long dot-traversal chains a bad idea when pages are so dynamic?</p>
        <p>Yes, of course. Don't do that. Use <code>query()</code> and <code>queryAll()</code> when doing "whole page" work. Dot-traversal is best for small, well-defined node structures, like getting the <code>&lt;li&gt;</code> elements in a <code>&lt;ul&gt;</code>.</p>
        <p class="question">Hey, this is like <a href="http://nbubna.github.io/HTML">HTML(.js)</a>...</p>
        <p>Of course, same author, similar concepts, better implementation. Consider it the official successor, with a better name than "HTML.js 2.0".</p>
        <p class="question">How is this better than HTML(.js)?</p>
        <p>
          <ul>
          <li>DOMx extends prototypes, rather than instances, making it faster and avoiding the need to use <code>HTML.ify(node)</code></li>
          <li>DOMx has more and better traversal abilities.</li>
          <li>Traversal methods always return a list or a node/null, not both. This is a bit less convenient but a lot more self-documenting, promoting maintenance-minded coding over the "quick 'n dirty" brand.</li>
          <li>Dot-traversal is no longer automatic, but must be turned on. This is both more robust and more performant.</li>
          <li>DOMx further reinforces the primacy of the native DOM by lacking any exported/global variable.</li>
          <li>DOMx adds powerful features for rich value get/set and templating.</li>
          </ul>
        </p>
        <p class="question">I have a suggestion, where do I put it?</p>
        <p>I do a happy dance when you <a href="http://github.com/esha/domx">create an issue on Github.</a></p>
      </div>
    </div>

  </div>
  <footer>
    <div class="wrapper">
      <p>An open-source project from <a href="http://esha.com">ESHA Research</a></p>
    </div>
  </footer>
</body>
<script src="script/domx-docs.js" type="text/javascript"></script>
<script>
    (function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
    function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
    e=o.createElement(i);r=o.getElementsByTagName(i)[0];
    e.src='//www.google-analytics.com/analytics.js';
    r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
    ga('create','UA-42479338-4');ga('send','pageview');
</script>
</html>
